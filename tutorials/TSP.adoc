:encoding: utf-8
:imagesdir: img
:cpp: C++

= Determine Robust Routes for the Noisy Traveling Salesman Problem

This tutorial

- Shows how to implement the noisy TSP problem aiming at a robust route efficiently using https://numba.pydata.org/[numba].
- Compares with an alternative implementation.
- Compares different optimization algorithms applied to both implementations

There is a dramatic performance difference > factor 10000 when comparing optimization algorithms  
and objective function implementations. The purpose of this tutorial is to "sharpen your senses"
regarding how to implement this kind of objective function and which optimization algorithm to choose
when you selected Python as implementation language. Don't underestimate the influence of
your specific implementation of a problem, not only regarding evaluations/second but also regarding
the number of evaluations required applying the same optimization algorithm. 

As starting point we use 
https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/problems/TSP.py[TSP.py]
from the 'ExpensiveOptimBenchmark' suite from the Technical University of Delft. 
In https://github.com/dietmarwo/fast-cma-es/blob/master/tutorials/Hospital.adoc[Hospital] we discuss four other
problems from this problem suite, but only for this one we provide our own alternative implementation. 

All results were produced using a 16 core / 32 thread AMD CPU 5950x. Some algorithms use only a single thread, 
others utilize the whole processor.  


=== Motivation

From https://arxiv.org/abs/1911.08817[Black-box Combinatorial Optimization using Models with Integer-valued Minima]:

"When a black-box optimization objective can only be evaluated with costly or noisy measurements, most standard optimization algorithms are unsuited to find the optimal solution. Specialized algorithms that deal with exactly this situation make use of surrogate models."

Such a method - specialized for integer-valued minima - is presented in the paper (https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/tree/master/expensiveoptimbenchmark/solvers/IDONE[IDONE]) and applied to a noisy variant of an asymmetric traveling salesman problem (17 cities).

The statement "most standard optimization algorithms are unsuited" is probably true, but what about the other ones?
We will identify "suited" standard optimization algorithms and prove
that they work fine for https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/problems/TSP.py[TSP.py],
the implementation of the objective function used in the paper. Additionally we can show that for an
alternative implementation of the same noisy TSP problem (100 iterations, noise=1.0)  
https://github.com/dietmarwo/fast-cma-es/blob/master/examples/noisy_tsp.py[noisy_tsp.py] standard optimization algorithms
can solve the noisy 17 cities problem BR17 in about 2 seconds utilizing the parallel threads modern CPUs provide. 

The other problem shown in the paper is artificial and based on matrix multiplication using 
random matrices with objective function: 

- `f(x) = (x − x^∗ )^T A(x − x^∗)` 

applied to binary input values. Here IDONE indeed uses far less function 
evaluations as all standard algorithms we tried. But what happens if
instead dimension = 100 we use dimension = 5000 ? IDONE doesn't scale very well, I wasn't able to apply it successfully. 
A standard algorithm (BiteOpt) uses about 900.000 function evaluations and about 5 hours (single threaded), 
but at least I got the problem solved. You could argue: Real world problems are too expensive to apply their objective
function so often, but on the other hand they usually cannot be solved so exceptionally well using IDONE.

=== The noisy Traveling Salesman Problem / TSP

The https://en.wikipedia.org/wiki/Traveling_salesman_problem[Traveling Salesman Problem/TSP] asks the question:
 "Given a list of cities and the distances between each pair of cities, what is the shortest possible 
 route that visits each city exactly once and returns to the origin city?"
It appears as subproblem in many other areas, is very well studied and there are methods solving it for large numbers
of cities. 

But what if the distance between cities is not known exactly? 
This problem can be "simulated" by adding some random noise to the individual distances and determining a "robust"
solution: We compute the path length n times and determine the "worst case", the longest path we got for all iterations
each time adding different random noise to the individual distances. For all our experiments we use 100 iterations
and a random noise between 0 and 1 added to all distances. 

Solving this "noisy TSP" is more challenging, standard branch and bound algorithms like https://github.com/LukasErlenbach/tsp_solver[tsp_solver] cannot be applied. 

=== The original implementation

Lets first have a look at https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/problems/TSP.py[TSP.py],
an implementation of an objective function computing the robust path length for continuous input values (mapped to discrete integers) determining
the selected tour. 

[source,python]
---- 
   def evaluate(self, x):
        robust_total_route_length = 0.0
        
        for iteration in range(self.n_iter):
            current = 0
            unvisited = list(range(1, self.d+2))
            total_route_length = 0.0

            for di, i in enumerate(x):
                next_up = unvisited.pop(int(round(i)))
                total_route_length += self.W[current, next_up]
                total_route_length += self.noise_rng.random() * self.noise_factor
                current = next_up

            last = unvisited.pop()
            total_route_length += self.W[current, last]
            total_route_length += self.noise_rng.random() * self.noise_factor
            total_route_length += self.W[last, 0]
            total_route_length += self.noise_rng.random() * self.noise_factor

            robust_total_route_length = max(total_route_length, robust_total_route_length)
        
        return robust_total_route_length
----


This implementation aims at minimizing the number of input variables: The number of cities N minus two. 
Since the tour is always a ring you can choose any fixed city as a starting point. When you have
performed N-2 steps there is only one city left, you haven't really a choice. 
`next_up = unvisited.pop(int(round(i)))` maps continuous input variables to integer values used
for the selection. At least for continuous optimizers you should use a different approach as we will
show below. 

=== Optimization algorithms

At https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/tree/master/expensiveoptimbenchmark/solvers[solvers]
we find a number of optimization algorithms to test. Many are not applicable for the TSP problem, 
so we choose the following selection for testing:

- https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/solvers/MVRSM[MVRSM]
- https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/tree/master/expensiveoptimbenchmark/solvers/IDONE[IDONE]
- https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/tree/master/expensiveoptimbenchmark/solvers/SA[Simulated Annealing]

We don't need a huge problem instance to drive these algorithms at and beyond their limits:
http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/atsp/br17.atsp.gz[br17] is a small TSP instance involving only 
17 cities. According to http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/ATSP.html[ATSP-solutions] the shortest path without noise 
has length 39.

image::original_solvers_comparison.png[]

Next lets have a look how fcmaes standard optimization algorithhms perform - also single threaded:
We use the Python wrapper of the following three algorithms implemented using Eigen/{cpp}: 

- https://github.com/dietmarwo/fast-cma-es/blob/master/_fcmaescpp/deoptimizer.cpp[Differential Evolution].
- https://github.com/dietmarwo/fast-cma-es/blob/master/_fcmaescpp/biteoptimizer.cpp[BiteOpt] from Aleksey Vaneev, see also https://github.com/avaneev/biteopt[BiteOpt]. 
- https://github.com/dietmarwo/fast-cma-es/blob/master/_fcmaescpp/acmaesoptimizer.cpp[CMA-ES].

image::fcmaes_single_thread_original_problem.png[]

The fcmaes CMA variant terminates fast, but provides inconsistent results. 

fcmaes supports the parallel retry of optimization algorithms, lets see what happens if we apply 32 optimization
runs in parallel using https://github.com/dietmarwo/fast-cma-es/blob/master/fcmaes/retry.py[retry.py] :

image::fcmaes_32_thread_original_problem.png[]

The original algorithms are clearly outperformed, 
even CMA-ES performs quite well when applied in a parallel retry scenario. 

==== UPDATE: Mixed integer support

Both the Differential Evolution and multiobjective DE/NSGA (MODE) algorithm got an update: 

- Both algorithms now have specific mixed-integer support. If you tell the algo via a new boolean
array `ints` parameter which are your discrete integer variables, convergence will be much faster. 
This works both for the Python and the C++ variants. `ints = [True, True, False]` for instance means
that the first two variables are discrete. Using `np.argsort(x)` together with continuous variables for
sequences as shown below is still a valid option. But this trick doesn't work if the same discrete value
can occur in different variables. The original problem is now solvable in about 10 seconds using multiple
threads.    

image::fcmaes_DE_mixed_integer_original_problem.png[]

==== An alternative implementation of the objective function

The new implementation 
(https://github.com/dietmarwo/fast-cma-es/blob/master/examples/noisy_tsp.py[noisy_tsp.py]) 
uses https://numba.pydata.org/[numba] to speed up the objective function evaluation quite significantly: 

[source,python]
---- 
@njit(fastmath=True) 
def evaluate_tsp(x, W, d, noise_factor, iter_num):
    robust_total_route_length = 0   
    order = np.argsort(x) + 1
    for _ in range(iter_num):
        total_route_length = 0
        total_route_length += W[0, order[0]] + np.random.random() * noise_factor            
        total_route_length += W[order[d-1], 0] + np.random.random() * noise_factor    
        for i in range(d-1):
            total_route_length += W[order[i], order[i+1]] + np.random.random() * noise_factor
        robust_total_route_length = max(total_route_length, robust_total_route_length)
    return robust_total_route_length
----
 

This implementation uses `np.argsort(x)` to determine the order the cities are visited. 
The first city is fixed, so we have the number of cities N minus one argument variables `x`.  
This is one variable more, but it nevertheless works much better with continuous optimization
algorithms. We used this idea also in 
https://github.com/dietmarwo/fast-cma-es/blob/master/tutorials/Scheduling.adoc[Scheduling] 
and https://github.com/dietmarwo/fast-cma-es/blob/master/tutorials/JobShop.adoc[JobShop]. 
 
Applying fcmaes standard optimization algorithms to the modified objective function 
 
image::fcmaes_32_thread_optimized_problem.png[] 
 
results in a solution time of about 2 seconds, even for CMA-ES its only about 5 seconds. 
 
Here a table comparing the number of function evaluations per second for all algorithms and 
objective function variants. https://numba.pydata.org/[numba] and the way the new implementation is designed 
speeds up the computation by about factor 100 thereby also improving convergence:
 
.Evaluations / second on CPU AMD 5950x
[width="80%",cols="2,^2,^2,^2",options="header"]
|=========================================================
|algorithm |problem |evals/sec |used threads
|idone |original |13 |1
|MSVRM |original |23 |1
|CMA |original |271 |1
|SA |original |335 |1
|BiteOpt |original |11800 |32
|fcmaes-CMA |original |11600 |32
|BiteOpt |numba based |1150000 |32
|fcmaes-CMA |numba based |1190000 |32
|=========================================================

=== Increasing the noise

What happens if we increase the noise? 
Another experiment uses the symmetrical TSP http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/gr17.tsp.gz[gr17]. 
This time we configured `noise_factor=50`. 
According to http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html[TSP-solutions] the shortest path without noise 
has length 2085. 

image::original_solvers_comparison_b.png[]

The CMA algorithm shown here is not the one from fcmaes, but the original one:

- https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/solvers/CMA[CMA-ES]

The CMA results are hard to see, reason is that we get a "termination on tolstagnation" 
after about 8000 function evaluations. It seems the default termination criteria don't work for the TSP problem.
As we will later see, this is not a problem with the CMA-ES algorithm itself. 

https://github.com/AlgTUDelft/ExpensiveOptimBenchmark/blob/master/expensiveoptimbenchmark/solvers/CMA[CMA-ES] is based on 
https://github.com/CMA-ES/pycma[pycma] from Nikolaus Hansen. 

Here are the results applying fcmaes-CMA (not the original one) 
and BiteOpt, both utilizing all 32 threads provided by the processor:

image::BiteOpt_fcmaes_CMA_original_comparison.png[]

Finally we see a direct comparison of the different objective function 
implementations for the same optimization algorithm. Beside 
the speedup (evaluations/sec) we find better robust tours using both
algorithms. 

image::BiteOpt_comparison.png[]

image::fcmaes_CMA_comparison.png[]

==== Conclusion

We have to be very careful when implementing an objective function representing a specific problem. 
Not always the implementation requiring the least number of variables wins. Use https://numba.pydata.org/[numba]
whenever possible for the time critical parts. BiteOpt or Differential Evolution, specially if used with parallel retry, 
are very good algorithm choices which should be tried early, if the problem is single objective and there are no
constraints (which cannot be easily expressed using the weighted sum approach). 
Algorithms with huge overhead like IDONE and MSVRM should only be applied for very expensive
objective functions. Noisy TSP can be evaluated nearly 1.2 million times / sec, so it definitely
doesn't fall into that category. 

